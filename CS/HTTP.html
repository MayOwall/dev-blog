<div class="markdown-body">
  <hr />
  <aside class="goal">함께 HTTP의 발전 과정과 특징에 대해 알아보아요! 😃</aside>

  <h2>HTTP란?</h2>
  <p>
    HTTP는 <code>HyperText Transfer Protocol</code>의 약자로,
    <strong>웹 상에서 정보를 주고 받을 수 있는 프로토콜</strong>을 의미합니다.
    처음에는 HTML등의 문서를 주고 받기 위한 목적으로 사용되었지만, 현재는
    HTML뿐만 아니라 이미지, 음성, 영상, 파일, JSON 등 byte로 표현할 수 있는 모든
    데이터를 HTTP를 통해 전송하고 있습니다.
  </p>
  <p><strong>즉 지금은 HTTP 시대!</strong></p>
  <h2>HTTP의 발전 과정</h2>
  <p>
    HTTP는 1996년 이전의 <code>HTTP 0.9</code>버전부터 시작되어 현재
    <code>HTTP 3.0</code>까지 발전해 왔습니다. HTTP 0.9부터 3.0까지의 발전은
    다음과 같습니다.
  </p>
  <h3>HTTP / 0.9 (1996 이전)</h3>
  <p>
    <code>HTTP/0.9</code>은 HTTP/1.0 이후의 버전들과 분류하기 위해 임시로 지어진
    명칭입니다.
  </p>
  <p>
    HTTP / 0.9의 요청은 <strong>오직 한줄의 라인으로 구성</strong>되었으며, 응답
    또한 HTML파일 하나로 매우 단순했습니다. 메서드도 GET밖에 존재하지 않았으며,
    헤더, 상태 코드 또한 존재하지 않았습니다.<br />하지만 너무나도 심플한
    구조였던 만큼 확장하여 사용하는데 한계가 있었습니다.
  </p>
  <h3>HTTP / 1.0 (1996)</h3>
  <p>
    <code>HTTP 1.0</code>은 기존의 제한적이던 0.9를 보다 융통성있게 사용하기
    위해 고안되었습니다.
  </p>
  <p>
    <code>HTTP 1.0</code>에는 헤더가 추가되어 HTML 문서 외의 다른
    자료(이미지)등을 전송하는 것이 가능해졌습니다. 또한 HTTP 버전, GET 이외의
    새로운 메서드(POST 등), 상태 코드 등이 추가되어
    <strong>기존의 HTTP 0.9보다 융통성 있는 사용이 가능</strong>해졌습니다.
  </p>
  <p>
    하지만 커넥션 하나당 요청 하나만 처리할 수 있었기에 서버 부하 비용이
    증가한다는 한계가 있었습니다.
  </p>
  <h3>HTTP / 1.1 (1997)</h3>
  <p><code>HTTP 1.1</code>은 최초의 HTTP 표준 버전입니다.</p>
  <p>
    <code>HTTP 1.1</code>에는 <code>Persist Connection</code>이 도입되었습니다.
    이를 통해 여러 요청이 하나의 커넥션을 통해 처리할 수 있게 되었습니다. 또한
    <code>Pipelining</code> 기법 등을 통해 기존의 한계를 극복할 수 있었습니다.
  </p>
  <p>
    이러한 특징들로 인해 HTTP 1.1은
    <strong>현재 가장 많이 사용되는 버전</strong>이 되었습니다.
  </p>
  <h3>HTTP / 2.0 &amp; HTTP / 3.0</h3>
  <p>
    <code>HTTP 2.0</code>와 <code>HTTP 3.0</code>은 기존 1.0 버전의
    <strong>성능 향상을 초점</strong>으로 하는 버전입니다.
  </p>
  <p>
    HTTP 2.0은 <code>바이너리 프레이밍 계층</code>을 사용해 파싱과 전송 속도를
    높이고 오류 발생 가능성이 줄어들었습니다. HTTP 3.0에서는
    <code>UDP 프로토콜</code>을 사용해 TCP 프로토콜의 3 Way Handshake를 생략하게
    되면서 더 빠른 통신이 가능해졌습니다.
  </p>
  <h2>HTTP 특징</h2>
  <p>HTTP는 다음과 같은 특징들을 가지고 있습니다.</p>
  <ol>
    <li>클라이언트 서버 구조 방식으로 동작함</li>
    <li>무상태 프로토콜을 지향</li>
    <li>비 연결성</li>
    <li>HTTP 메세지를 통해 통신</li>
  </ol>
  <p>특징들에 대해 하나씩 알아보도록 할까요?</p>
  <h3>클라이언트 서버 구조</h3>
  <img
    src="https://images.velog.io/images/dnflekf2748/post/3ae851c0-f5a1-4b24-a9f0-00dd4d1efe2d/%EC%84%9C%EB%B2%84%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8.png"
  />
  <p>
    클라이언트 서버 구조란 클라이언트(Request)와 서버(Response)으로<br />이루어진
    구조를 의미합니다. 클라이언트는 서버에 요청이 보내 응답이 올 때 까지
    대기하며, 서버는 클라이언트의 요청에 대한 결과를 만들어 응답을 보내는
    방식으로 작동합니다.
  </p>
  <p>
    예전에는 클라이언트와 서버의 개념의 구분되지 않았으나, 웹이 급속도로
    발전하고 사용자 사용성과 비즈니스 로직 등이 각각 분리되어 발전될 필요성이
    대두되면서, 클라이언트와 서버 2 개념으로 분리가 이루어졌습니다.
  </p>
  <p>HTTP는 이러한 클라이언트 서버 구조 방식으로 통신이 이루어지게 됩니다.</p>
  <h3>무상태 프로토콜 (Stateless Protocol)</h3>
  <img
    src="https://t3700013.p.clickup-attachments.com/t3700013/1886fa98-992a-4a38-a807-4f769c2ceb0b/1_7BA8zaVExmMRpTlvtGaT5g.png"
  />
  <p>
    서버가 클라이언트의 상태를 보존하지 않는 것을 의미합니다. 서버가
    클라이언트의 상태를 기억하지 않아도 되기 때문에 갑작스러운 컨텍스트 변경,
    HTTP 요청이 증가, 기존 서버에서 에러가 발생해도 유연하게 대처할 수 있다는
    장점이 있습니다.<br />하지만 한번 통신이 이루어질 때 많은 데이터가
    필요하다는 단점이 존재합니다.
  </p>
  <p>반대 개념으로는 상태 유지(Stateful)가 있습니다.</p>
  <h3>비 연결성 (Connectionless)</h3>
  <img
    src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x/http1_x_connections.png"
  />
  <p>
    클라이언트와의 통신이 끝날 때 마다 연결 또한 끊는 것을 의미합니다. 이를 통해
    서버를 최소한의 자원으로 효율적으로 유지할 수 있다는 장점이 있습니다.<br />Ex)
    1시간 동안 수천명의 사용자가 함께 이용해도, 매 순간 처리하는 요청은 수십개
    이하로 적게 유지가 가능해짐
  </p>
  <p>
    하지만 매 요청/응답마다 새로운 TCP/IP 연결을 생성해야 하기 때문에,
    클라이언트 입장에서 응답이 느리게 느껴질 수 있다는 단점이 있습니다. 또한
    HTTP에 자바스크립트, CSS, 이미지 등이 한번에 전송되게 되면서 HTTP가 무거워져
    응답 자체가 느려지게 됩니다.
  </p>
  <p>
    다행히 HTTP 1.1에서 Persistent Connections이 도입되면서 기존의 매
    요청/응답마다 연결을 생성해 응답이 느려진다는 한계를 극복할 수 있게
    됐습니다.
  </p>
  <h3>HTTP 메세지</h3>
  <img
    src="https://www.studytonight.com/ezoimgfmt/s3.ap-south-1.amazonaws.com/s3.studytonight.com/tutorials/uploads/pictures/1611906247-71449.png?ezimgfmt=ngcb3/notWebP"
  />
  <p>
    HTTP는 메세지를 통해 통신이 이루어지며, HTTP 메세지는 정해진 규격으로
    이루어져 있습니다.
  </p>
  <h4>start-line</h4>
  <p>
    HTTP 메세지의 시작 라인을 의미합니다. 크게 request-line과 status-line으로
    구성되어 있습니다.
  </p>
  <ul>
    <li>
      request-line : 요청시 사용되는 start-line. HTTP 메서드, 요청 대상, HTTP
      Version으로 구성
    </li>
    <li>
      status-line : 응답시 사용되는 start-line. HTTP-version,
      status-code(상태코드), reason-phrase로 구성
    </li>
  </ul>
  <h4>header</h4>
  <p>
    HTTP 전송에 필요한 모든 부가정보를 담는 용도로 사용됩니다. 필요시 사용자가
    임의의 헤더 추가할 수 있습니다.<br />| Ex. 메세지 바디의 크기, 압축여부,
    인증정보, 요청 클라이언트 브라우저 정보, 캐시 관리 정보…등등
  </p>
  <h4>empty line : 공백 라인</h4>
  <p>
    header와 Message-body 사이에 반드시 존재해야 하는 공백입니다. Message-body가
    없는 경우(GET 메서드 일 때)라도 반드시 공백 라인이 있어야 합니다.
  </p>
  <h4>message body</h4>
  <p>
    실제로 전송하는 데이터를 의미합니다. HTML 문서, 이미지, 영상, JSON 등등
    byte로 표현할 수 있는 모든 데이터가 전송 가능합니다.
  </p>

  <h3>마무리하며</h3>
  <p>
    오늘은 이렇게 HTTP의 발전 과정과 HTTP의 특징에 대해 알아보는 과정을
    가졌습니다. HTTP가 대통합되어 오늘날 일반적으로 사용되기까지 결코 쉬운
    과정은 아니었다는 것이 인상깊습니다. 기존의 다채로웠던 통신방식에서 간결한
    HTTP로 통신규약이 대통합 된 것을 보면, 역시 크게 성공하는 기술은 단순하지만,
    확장하기 쉬운 기술인 것 같습니다. 😆
  </p>
</div>
